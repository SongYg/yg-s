# 面试题目汇总
## OS
* 进程和线程
    1. 进程和线程的区别？
        - xxx
    2. 为什么线程切换开销小？
        - 进程是OS最小分配单位，操作系统生成一个进程需要分配其大量资源，包括内存、I/O、寄存器等等，操作系统切换进程需要保存当前进程执行上下文，进行进程切换就需要回复之前执行时候的上下文，有可能还需要重新调回内存页面等，进程的切换会产生大量的资源消耗。而线程是在进程内部切换，需要操作系统来切换执行。线程之间有一些更方便的共享机制，保证线程切换资源消耗少。

## Java

## Python
* 爬虫
    1. 遇到的反爬虫策略
        - 通过Headers反爬虫，在chrome source里面可以找到相应的Headers，添加上可以反反爬虫
        - 通过分析IP访问频率反爬虫，这是基于用户行为的，短时间大量访问请求下可以直接使用Nginx封锁，可以使用IP代理
        - 网页内容通过Ajex动态加载，使用selenium抓取，速度会收影响，可以开多进程加速
        - 加密，使用selenium截图+OCR
    1. 

## 数据库
## 网络
* OSI 5层结构
    * 应用层、（表示层、会话层）、传输层、网络层、链路层、物理层
    * 应用层协议（HTTP、STP、SMTP、DNS），传输层（TCP、UDP），网络层（IP），链路层（ARP、Frame）
* 传输层：
    * UDP与TCP的区别
        * TCP是面向连接的，UDP是无连接的；
        * TCP是可靠的，UDP是不可靠的；
        * TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
        * TCP是面向字节流的，UDP是面向报文的，TCP把数据当成字节流，UDP只管发应用层传下的数据；
        * TCP有拥塞控制机制，UDP没有拥塞控制，适合媒体通信；
        * TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大
    * TCP协议如何保证可靠传输的？
        * 数据包检验，检验和校准；TCP的可靠传输通过校验和+超时重传实现；Sequence和ACK确认机制，保证有序；丢弃重复报文；超时重传；拥塞避免。
    * TCP协议的流量控制
        * 通过滑动窗口模型进行流量控制，开始传输数据时，交换各自滑动窗口大小，之后的TCP包头中窗口大小；1个数据探测回复窗口
    * TCP的拥塞控制机制
        * 拥塞控制主要是减轻网络负担，流量控制主要是为了减轻点和点之间的负担。
        * 慢启动(slow-start)，又称为慢开始：一个报文增加1，一个RTT翻一番
        * 拥塞避免(congestion avoidance)：大于阈值，每一个RTT加一，ssh减半
        * 快重传(fast retransmit)：三个重复报文，重新发送未确认的报文段
        * 快恢复(fast recovery)：ssh减半，拥塞避免算法
        ![TCP拥塞控制机制](https://github.com/SongYg/yg-s/blob/master/fig/tcp.png?raw=true)

    * 三次握手与四次挥手
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/tcp-connect.png?raw=true)
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/tcp-close.png?raw=true)

    * 为什么采用3次握手而不是2次？
        * 防止“失效的连接请求”在服务器端占用资源客户端发出了连接请求，但该数据报在网络中某处滞留了客户端等待超时后，重发连接请求，服务器响应，建立连接滞留的连接请求又到达服务器端，如果采用2次握手，服务器将建立一个连接，分配资源(缓冲区、定时器、…) 占用资源且长期存活

    * 3次握手带来的安全问题：TCP  SYN  Flooding攻击
        * 攻击者连续发送大量SYN报文，但却不对SYN ACK报文做出响应结果：服务器内部数据结构满，无法响应正常用户的TCP连接请求此类攻击大多使用IP地址伪装，使得对攻击源的定位比较困难Linux内核采用了SYN_Cookies机制应对这种攻击基本思路：服务器返回SYN+ACK时，根据自身特有信息(时间戳、IP地址、端口号等)计算Cookies，作为seq返回给客户端，并在收到对方应答前，不为该连接分配数据结构

* HTTP
    * 浏览器访问HTTP网页过程：
        * 浏览器查询缓存寻找URL对应的IP
        * 经过本机DNS系统和DNS服务器（本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器）得到IP
        * 三次握手建立TCP连接
        * 只有建立连接后才能开始传输数据，此时才开始HTTP协议，如发送GET请求
        * 服务器发送HTML超文本
        * 关闭TCP连接，四次挥手
        * 浏览器解析
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/http-query.png?raw=true)
    * HTTP报文：
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/http-query.png?raw=true)
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/http-query.png?raw=true)

    * HTTP常见状态码
        * HTTP是无状态的：服务器不记录客户端的访问状态：对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即给服务器发送 HTTP 请求之后，服务器根据请求发送数据，发送完毕不会记录任何信息。
        * 状态码都是三位数字，状态码指的是一次请求下HTTP的响应返回。
        * 1xx：表示通知信息的，如请求收到了或正在进行处理
            * 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
        * 2xx：表示成功，如接受或知道了
            * 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页
        * 3xx：表示重定向，表示要完成请求还必须采取进一步的行动
            * 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
            * 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
            * 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
        * 4xx：表示客户的差错，如请求中有错误的语法或不能完成
            * 400 (错误请求) 服务器不理解请求的语法。
            * 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
        * 5xx：表示服务器的差错，如服务器失效无法完成请求
            * 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
    * Session、Cookie 与 Application
        * HTTP是无状态的，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
    * HTTP和HTTPS的区别
    * POST与 GET的区别
        * GET数据传输安全性低，POST传输数据安全性高，因为参数不会被保存在浏览器历史或web服务器日志中；
        * 在做数据查询时，建议用GET方式；而在做数据添加、修改或删除时，建议用POST方式；
        * GET在url中传递数据，数据信息放在请求头中；而POST请求信息放在请求体中进行传递数据；
        * GET传输数据的数据量较小，只能在请求头中发送数据，而POST传输数据信息比较大，一般不受限制；
        * 在执行效率来说，GET比POST好

## 算法
## 数据结构