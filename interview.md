# 面试题目汇总
## OS
* 进程和线程
    * 并发和并行
        * 并发Concurrent：两个活动在某一时刻都同处于其起点和终点的某一刻。
        * 并行Parallel：如果考虑两个程序,它们在同一时间度量下同时运行，则称这两个程序是并行执行的。
        * 并发和并行可以从操作系统微观角度考虑，靠操作系统不断地在微观层面上进程切换，而在宏观“看到的样子”是同时执行的，这叫并发。


    * 进程的状态：
        * 就绪状态
        * 执行状态
        * 阻塞状态
        ![TCP拥塞控制机制](https://github.com/SongYg/yg-s/blob/master/fig/process-status.png?raw=true)


    * 进程和线程的区别？
        * 进程是程序的一次执行；进程 = 进程控制块 + 程序 + 数据；进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。
        * 进程包含了两个概念：资源拥有者和可执行单元。可执行单元称为线程，线程是进程中的一个实体，是一个CPU调度和分派的单位。进程更像是资源环境 + 执行计算
        * 线程基本上不拥有资源，只有必不可少的少量资源，以与其他同进程的线程共享进程拥有的所有资源


    * 为什么引入线程？
        * 减小进程切换的开销
        * 提高进程内的并发程度
        * 共享资源


    * 为什么线程切换开销小？
        * 进程是OS最小分配单位，操作系统生成一个进程需要分配其大量资源，包括内存、I/O、寄存器等等，操作系统切换进程需要保存当前进程执行上下文，进行进程切换就需要回复之前执行时候的上下文，有可能还需要重新调回内存页面等，进程的切换会产生大量的资源消耗。而线程是在进程内部切换，需要操作系统来切换执行。线程之间有一些更方便的共享机制，保证线程切换资源消耗少。


    * 进程通信方式？
        * 每个进程都有各自用户内存空间，进程进程间无法交流，进程间通信方式实际上是内核缓冲区开出一个区域，用于进程间的通信。
        * 管道
            * 实际是内核缓冲区
            * 一个进程写入一个进程读，只能半双工交流数据
            * 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)
        * 有名管道
            * 有名管道的名字存在于文件系统中，内容存放在内存中
            * 通过文件系统的路径，解决只允许亲缘关系进程之间的通信
        * 信号
            * 信号可以在任何时候发给某一进程，而无需知道该进程的状态
            * 常见信号有：SIGINT、SIGQUIT 退出进程Ctrl+c，SIGKILL、SIGTERM杀掉进程
        * 消息队列
            * 内核中的消息链表
            * 消息队列允许一个或多个进程向它写入与读取消息
        * 共享内存
            * 内核一块内存区域，由需要访问的进程将其映射到自己的私有地址空间，直接进行读写，这样无需复制数据
        * 信号量
            * PV操作
        * 套接字协议


    * 线程同步与互斥的方式？
        * 临界区、互斥锁用于线程之间互斥控制
        * 信号量、事件对象用于线程之间同步：PV操作，事件是一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务

    * 进程调度算法
        * TODO


    * 什么是死锁？死锁产生的条件？
        * 两个或多个进程，请求到一定资源而又在等他其他资源，陷入无限等待。如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。
        * 四个必要条件：
            * 互斥：任一时刻只允许一个进程使用资源
            * 不可剥夺：进程已经占用的资源，不会被强制剥夺
            * 请求和保持：进程在请求其余资源时，不主动释放已经占用的资源
            * 环路等待：存在进程的循环等待链，前一进程占有的资源正是后一进程所需求的资源。
    * 解除死锁
        * 处理死锁的基本方法
            * 预防死锁：破坏死锁的四个条件
            * 避免死锁：银行家算法
            * 检测死锁：资源分配图，判断是否有循环等待。
            * 解除死锁：撤销进程法：撤销全部进程，释放所有资源，有序恢复；资源剥夺法：挂起一部分进程，剥夺资源，带条件成熟再激活

* 内存
* I/O



## Java

## Python
* 爬虫
    * 遇到的反爬虫策略
        * 通过Headers反爬虫，在chrome source里面可以找到相应的Headers，添加上可以反反爬虫
        * 通过分析IP访问频率反爬虫，这是基于用户行为的，短时间大量访问请求下可以直接使用Nginx封锁，可以使用IP代理
        * 网页内容通过Ajex动态加载，使用selenium抓取，速度会收影响，可以开多进程加速
        * 加密，使用selenium截图+OCR


* `__init__` 和 `__new__` 的区别
    * 两者都会在实例化对象的时候调用，Python没有C++和Java中new关键字，但是在实例化对象的时候会调用 `__new__` 函数返回实例化对象
    * `__new__` 之后调用 `__init__` 函数对对象进行初始化，比如初始化实例的属性值等
    * `__new__` 可以用来在Python中实现单例模式的类

* 迭代器和生成器
    * 迭代器是Python中可以迭代访问的类型，比如说list的遍历，`for x in x_list`就是使用了Python中的迭代器。如果想要实现一个迭代器，只需要在自己定义的类中定义`__next__`与`__iter__`两个方法，在迭代器结束地方抛出 `stopInteration`
    * 生成器，比如生成list时，比如yield

* `*args **kwargs`
    * 无名参数和关键字参数


* lambda 表达式
    * sort排序时候使用lambda表达式
    * map filter reduce时候使用lambda表达式

* Django
    * MVC
    * 设计模式
    * 

## 数据库
## 网络
* OSI 5层结构
    * 应用层、（表示层、会话层）、传输层、网络层、链路层、物理层
    * 应用层协议（HTTP、STP、SMTP、DNS），传输层（TCP、UDP），网络层（IP），链路层（ARP、Frame）
* 传输层：
    * UDP与TCP的区别
        * TCP是面向连接的，UDP是无连接的；
        * TCP是可靠的，UDP是不可靠的；
        * TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
        * TCP是面向字节流的，UDP是面向报文的，TCP把数据当成字节流，UDP只管发应用层传下的数据；
        * TCP有拥塞控制机制，UDP没有拥塞控制，适合媒体通信；
        * TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大
    * TCP协议如何保证可靠传输的？
        * 数据包检验，检验和校准；TCP的可靠传输通过校验和+超时重传实现；Sequence和ACK确认机制，保证有序；丢弃重复报文；超时重传；拥塞避免。
    * TCP协议的流量控制
        * 通过滑动窗口模型进行流量控制，开始传输数据时，交换各自滑动窗口大小，之后的TCP包头中窗口大小；1个数据探测回复窗口
    * TCP的拥塞控制机制
        * 拥塞控制主要是减轻网络负担，流量控制主要是为了减轻点和点之间的负担。
        * 慢启动(slow-start)，又称为慢开始：一个报文增加1，一个RTT翻一番
        * 拥塞避免(congestion avoidance)：大于阈值，每一个RTT加一，ssh减半
        * 快重传(fast retransmit)：三个重复报文，重新发送未确认的报文段
        * 快恢复(fast recovery)：ssh减半，拥塞避免算法
        ![TCP拥塞控制机制](https://github.com/SongYg/yg-s/blob/master/fig/tcp.png?raw=true)

    * 三次握手与四次挥手
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/tcp-connect.png?raw=true)
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/tcp-close.png?raw=true)

    * 为什么采用3次握手而不是2次？
        * 防止“失效的连接请求”在服务器端占用资源客户端发出了连接请求，但该数据报在网络中某处滞留了客户端等待超时后，重发连接请求，服务器响应，建立连接滞留的连接请求又到达服务器端，如果采用2次握手，服务器将建立一个连接，分配资源(缓冲区、定时器、…) 占用资源且长期存活

    * 3次握手带来的安全问题：TCP  SYN  Flooding攻击
        * 攻击者连续发送大量SYN报文，但却不对SYN ACK报文做出响应结果：服务器内部数据结构满，无法响应正常用户的TCP连接请求此类攻击大多使用IP地址伪装，使得对攻击源的定位比较困难Linux内核采用了SYN_Cookies机制应对这种攻击
        * 基本思路：服务器返回SYN+ACK时，根据自身特有信息(时间戳、IP地址、端口号等)计算Cookies，作为seq返回给客户端，并在收到对方应答前，不为该连接分配数据结构

* HTTP
    * 浏览器访问HTTP网页过程：
        * 浏览器查询缓存寻找URL对应的IP
        * 经过本机DNS系统和DNS服务器（本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器）得到IP
        * 三次握手建立TCP连接
        * 只有建立连接后才能开始传输数据，此时才开始HTTP协议，如发送GET请求
        * 服务器发送HTML超文本
        * 关闭TCP连接，四次挥手
        * 浏览器解析
        ![三次握手连接](https://github.com/SongYg/yg-s/blob/master/fig/http-query.png?raw=true)
    * HTTP报文：
        ![HTTP请求报文](https://github.com/SongYg/yg-s/blob/master/fig/http-request.png?raw=true)
        ![HTTP应答报文v](https://github.com/SongYg/yg-s/blob/master/fig/http-response.png?raw=true)

    * HTTP常见状态码
        * HTTP是无状态的：服务器不记录客户端的访问状态：对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即给服务器发送 HTTP 请求之后，服务器根据请求发送数据，发送完毕不会记录任何信息。
        * 状态码都是三位数字，状态码指的是一次请求下HTTP的响应返回。
        * 1xx：表示通知信息的，如请求收到了或正在进行处理
            * 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
        * 2xx：表示成功，如接受或知道了
            * 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页
        * 3xx：表示重定向，表示要完成请求还必须采取进一步的行动
            * 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
            * 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
            * 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
        * 4xx：表示客户的差错，如请求中有错误的语法或不能完成
            * 400 (错误请求) 服务器不理解请求的语法。
            * 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
        * 5xx：表示服务器的差错，如服务器失效无法完成请求
            * 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
    * Session、Cookie 与 Application
        * HTTP是无状态的，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
    * HTTP和HTTPS的区别
    * POST与 GET的区别
        * GET数据传输安全性低，POST传输数据安全性高，因为参数不会被保存在浏览器历史或web服务器日志中；
        * 在做数据查询时，建议用GET方式；而在做数据添加、修改或删除时，建议用POST方式；
        * GET在url中传递数据，数据信息放在请求头中；而POST请求信息放在请求体中进行传递数据；
        * GET传输数据的数据量较小，只能在请求头中发送数据，而POST传输数据信息比较大，一般不受限制；
        * 在执行效率来说，GET比POST好

## 算法
## 数据结构